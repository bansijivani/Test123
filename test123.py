#this file will print helloworld
print ('hello world!')


#!/usr/bin/env python3
import os
import argparse
import shlex

# Argument parsing
parser = argparse.ArgumentParser(
    description="Generate a meson crossfile based on environment variables")
parser.add_argument('--type',
    choices=['internal', 'external-cross', 'external-native'],
    default='internal',
    help="""
internal:   Internal crossfile used when contribs are cross-compiled.
            Not meant for use outside the contribs build.
external-*: External machine file (either cross or native).
            This is meant to be used by VLCs meson build system to easily
            use the given contribs, similar to --with-contrib=DIR for ./configure
""")
parser.add_argument('file', type=argparse.FileType('w', encoding='UTF-8'),
    help="output file")
args = parser.parse_args()

# Helper to add env variable value to crossfile
def _add_environ_val(meson_key, env_key):
    env_value = os.environ.get(env_key)
    if env_value != None:
        args.file.write("{} = '{}'\n".format(meson_key, env_value))

# Helper to single-quote array items
def _quote_arr(arr):
    return ["'" + item + "'" for item in arr]

# Helper to add an array to crossfile
def _add_arr(meson_key, arr, literal=False):
    if not literal:
        arr = _quote_arr(arr)
    arr_string = (', '.join(arr))
    args.file.write("{} = [{}]\n".format(meson_key, arr_string))

# Helper to add env variable array to crossfile
def _add_environ_arr(meson_key, env_key):
    env_array = os.environ.get(env_key)
    if env_array != None:
        env_values = shlex.split(env_array)
        _add_arr(meson_key, env_values)

# Generate meson crossfile
args.file.write("# Automatically generated by contrib makefile\n")

if args.type == 'internal':
    # Binaries section
    args.file.write("\n[binaries]\n")
    _add_environ_val('c', 'CC')
    _add_environ_val('cpp', 'CXX')
    if os.environ.get('HOST_SYSTEM') == 'darwin':
        _add_environ_val('objc', 'OBJC')
        _add_environ_val('objcpp', 'OBJCXX')
    _add_environ_val('ar', 'AR')
    _add_environ_val('strip', 'STRIP')
    _add_environ_val('pkgconfig', 'PKG_CONFIG')
    _add_environ_val('windres', 'WINDRES')

    # Properties section
    args.file.write("\n[properties]\n")
    args.file.write("needs_exe_wrapper = true\n")
    _add_environ_val('pkg_config_libdir', 'PKG_CONFIG_LIBDIR')

    # Host machine section
    args.file.write("\n[host_machine]\n")
    _add_environ_val('system', 'HOST_SYSTEM')
    _add_environ_val('cpu_family', 'HOST_ARCH')
    args.file.write("endian = 'little'\n")

    # Get first part of triplet
    cpu = os.environ.get('HOST', '').split('-')[0]
    args.file.write("cpu = '{}'\n".format(cpu))

    # CMake section
    args.file.write("\n[cmake]\n")
    _add_environ_val('CMAKE_C_COMPILER', 'CC')
    _add_environ_val('CMAKE_CXX_COMPILER', 'CXX')
    _add_environ_val('CMAKE_SYSTEM_NAME', 'CMAKE_SYSTEM_NAME')
    _add_environ_val('CMAKE_SYSTEM_PROCESSOR', 'ARCH')

elif args.type.startswith('external'):
    # Constants section
    args.file.write("\n[constants]\n")
    args.file.write("contrib_dir = '{}'\n".format(os.environ['PREFIX']))
    args.file.write("contrib_libdir = contrib_dir / 'lib'\n")
    args.file.write("contrib_incdir = contrib_dir / 'include'\n")
    args.file.write("contrib_pkgconfdir = contrib_libdir / 'pkgconfig'\n")

    # Properties section
    args.file.write("\n[properties]\n")
    args.file.write("contrib_dir = contrib_dir\n")
    args.file.write("contrib_libdir = contrib_libdir\n")
    args.file.write("contrib_incdir = contrib_incdir\n")

    pkgconfdir_arr = ['contrib_pkgconfdir']
    if args.type == 'external-cross':
        if os.environ.get('PKG_CONFIG', 'pkg-config') == 'pkg-config':
            # If we have no host-specific pkg-config, set the libdir
            # so we do not pick up incompatible deps.
            _add_arr('pkg_config_libdir', pkgconfdir_arr, literal=True)
    else:
        pkgconfpath = os.environ.get('PKG_CONFIG_PATH')
        if pkgconfpath is not None:
            args.file.write("\n[built-in options]\n")
            _add_arr('pkg_config_path', filter(None, pkgconfpath.split(':')))

else:
    assert False, 'Unhandled type!'




#! /usr/bin/env python3
# -*- coding: utf-8 -*-
import sys
import json
import fontforge
import six
from jinja2 import Template

DOC= """
transform a batch of SVG to a font usable in QML. a QML object is generated to serve as an index

known issues:

  - SVG should not have overlapping
  - SVG should have a viewbox equal to the size of the SVG, ie:
         <svg width="48" height="48" viewBox="0 0 48 48">

Input files must respect the format described by CONFIG_SCHEMA
"""

CONFIG_SCHEMA = {
    "type": "object",
    "properties": {
        "qml_name": { "type" : "string", "description" : "name of the generated QML class {{qml_name}}.qml" },
	"qml_file_prefix": { "type" : "string", "description" : "import path within QML" },
	"font_file": { "type" : "string", "description" : "output font file" },
	"font_name": { "type" : "string", "description": "font family name" },
	"glyphs" : {
            "type" : "array",
            "items" : {
                "type": "object",
                "properties" : {
                    "key" : { "type" : "string", "description": "keyword of the glyph, should be unique within the list" },
                    "path" : { "type" : "string", "description" : "path of the SVG to use for glyph" },
                    "charcode" : { "type" : "string", "description": "utf8 code" },
                },
                "required": ["key", "path"]
            }
        }
    },
    "required": ["glyphs", "qml_name", "font_name", "font_file", "qml_file_prefix"]
}


QML_TEMPLATE=u"""
/**
 * This file was generated by makeIconFont.py, please do not edit by hand
 */
pragma Singleton
import QtQuick 2.11

QtObject {
    readonly property FontLoader fontLoader : FontLoader {
        source: "{{qml_file_prefix}}{{font_file}}"
    }

    readonly property string fontFamily: "{{font_name}}"

    // Icons
{% for f in glyphs %}    readonly property string {{f.key}} : "{{f.charcode}}"
{% endfor %}
}

"""

UTF8_AREA = 0xE000

def genQml(data):
    template = Template(QML_TEMPLATE)
    qmlout = template.render(**data)
    with open(data["qml_name"], "w+") as fd:
        fd.write(qmlout)

def validateModel(model):
    try:
        import jsonschema
    except ImportError:
        return True

    jsonschema.validate(model, CONFIG_SCHEMA)
    return True

def main(model_fd):
    data = json.load(model_fd)
    if not data:
        return

    validateModel(data)

    font = fontforge.font()
    font.familyname = data["font_name"]
    font.fontname = data["font_name"]
    font.design_size = 1024.0

    font.hasvmetrics = True

    font.upos=0
    font.ascent = 1024
    font.descent = 0

    font.hhea_ascent = 1024
    font.hhea_ascent_add = False
    font.hhea_descent = 0
    font.hhea_descent_add = False
    font.hhea_linegap = 0

    font.os2_use_typo_metrics = True
    font.os2_typoascent = 1024
    font.os2_typoascent_add = False
    font.os2_typodescent = 0
    font.os2_typodescent_add = False
    font.os2_typolinegap = 0

    font.os2_winascent = 1024
    font.os2_winascent_add = False
    font.os2_windescent = 0
    font.os2_windescent_add = False

    for i, glyph in enumerate(data["glyphs"]):
        charcode = UTF8_AREA + i
        c = font.createChar(charcode)
        glyph["charcode"]  = "\\u{:x}".format(charcode)
        c.importOutlines(glyph["path"])
        #scale glyph to fit between 200 (base line) and 800 (x 0.6)
        #c.transform((0.6, 0.0, 0.0, 0.6, 200, 200.))
        c.vwidth = 1024
        c.width = 1024

    font.generate(data["font_file"])
    genQml(data)

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="generate an icon font for QML from SVG")
    parser.add_argument("model", metavar="model",type=argparse.FileType("r"), default=sys.stdin,
                        help="the input model")
    args = parser.parse_args()
    main(args.model)
